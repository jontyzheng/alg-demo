package jin.array;

/**
 * 最大子序和
 * 这道题关键就是如何【在连续累加的过程，又不破坏上一步找到的最大和】
 * 挑战就是在遇到累加和为负数时，应该怎么办：
 * 此时，因为先前算好的最大值只有在【比较满足条件】后更新，所以不会被累加到更小的情况影响
 * 重要的是选择从哪里开始，继续下一个累计起点。
 * 当加到负数时，说明再往后，就算遇到一个极大的正数，都不如直接就从后面的正数开始加划算。
 * 而将(临时)累加和赋值为当前使其变成负数的数字恰好也可以巧妙地化解这个问题
 * 如果是负数，令临时和等于当前数字，等到下一个就算也是负数，也会被判断赋值，更新起点 √
 * 如果是正数，正数的位置不可能是破坏临时和往上加的。
 */
public class MaxSubArray {

    public int maxSubArray(int[] nums) {
        int res = nums[0];  // 数组长度无论是一个还是多个，都是从第一个开始的
        int sum = 0;
        for (int num : nums) {
            // 往后累加求和：什么情况下"亏的会被赚回来呢"
            // 这时候手上还有钱，可以继续往后博(往后试触更大和的过程就像拿手里的钱去赌博的过程)
            // 手上还有钱可以继续赌：大了就更新仓库里的钱，亏了就不变，赚了就换成红包走人
            if (sum > 0) {
                sum += num;
            } else {
                // 如果手上的钱光了，说明要么上一笔后面没有碰到更好的钞了(但每次只有赚了才存，所以实际没亏)
                // 此时调整策略：当手上的钱已经倒贴时，说明继续往后一定不是从这个起点开始算的
                // [那有没有可能再往后加就刚好赚回本了？]
                // 不可能：【因为到这里都已经是负数了，就算后面遇到一个更大的数，累加上这个负数也不如直接从下一个数字开始】
                // [那有没有可能不是从上一个位置开始，而是从上一个开始位置的后面一个开始，下一个更大的累加和？]
                // 让最大子序和破坏的地方一定是让原累加和变成负数的地方
                // 在遇到这种地方时如何计算下一个最大子序和，从谁开始
                // 从破坏的地方开始：如 (4 -1 2 1) -5 4
                // 此时就从 因为 6 已经被保存了起来，所以 6-5+4 = 2 变成正数，也不会影响原来的【res】
                sum = num;
                // 每一次，都可以从破坏的位置开始计算
                // 因为这个数要么时极负，遇到下一个负数也会因为负数被过滤掉，【直到从一个正数代替】
            }
            if (sum > num) {
                res = sum;  // 每次都停下来数钱，赚了存起 继续往前走【赚了才存，否则不亏】
            }
        }
        return res;
    }
}
/**
 * https://leetcode-cn.com/problems/maximum-subarray/
 * 最小子序和
 * Reference:https://leetcode-cn.com/problems/maximum-subarray/comments/2002
 * 妥妥的博弈
 * 1、以临时 sum 去试触更大子序和
 * 2、只有更大时才更新最大值，保证了先前算好的最大子序和不被破坏
 * 3、每一次都有一次对临时和的比对和刷新，确保每次有更大连续和出现时，最大子序和总是能被通知
 * 4、当临时和(手上的钱)亏到倒贴时，提醒起点应该更新了，表示当前包括当天遇到的都不是一个最好的起点
 * (下一个就算更大，放弃先前负数的临时和也只入不敷出)
 * 5、每次计算临时和，只在手上钱保证为一个正数，或者至少为当天的数字
 * */
